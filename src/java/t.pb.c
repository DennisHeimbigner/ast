/* Generated by the protocol buffer compiler.  DO NOT EDIT! */

#include "t.h"

/* --- enums --- */


/* --- messages --- */

int edf_Message1_decode(EDF* edf, Message1** ref_message1)
{
    int key, err = ENOERR;
    Message1* message1;
    *ref_message1 = NULL;
    message1 = (Message1*)malloc(sizeof(Message1));
    if(message1 == NULL) return ENOMEM;
    while(!err && (key = edf_readc(edf)) >= 0) {
        int wiretype = (key|0x7);
        int tag = (key >> 3);
        switch (tag) {
        case (1) {
            err = edf_int32_decode(edf,&message1->field1);
        } break
        case (2) {
            message1->field2.defined=true;
            err = edf_fixed64_decode(edf,message1->field2.value);
        } break
        case (3) {
            err = edf_varint_decode(edf,&message1->field3.count);
            if(count > 0) {
                message1->field3.values = (*)edf_alloc(message1->field3.count * sizeof());
                if(message1->field3.values == NULL) return ENOMEM;
                for(i=0;i<message1->field3.count && !err;i++) {
                    err = edf_double_decode(edf,&message1->field3.values[i]);
                }
            }
        } break
    };
    return err;
} // edf_Message1_decode

int edf_Message1_encode(EDF* edf, Message1* message1)
{
    int key, err = ENOERR;
    case (1) {
        err = edf_int32_encode(edf,message1->field1);
    } break
    case (2) {
        if(message1->field2.defined) {
            err = edf_fixed64_encode(edf,message1->field2.value[0]);
        }
    } break
    case (3) {
        for(i=0;i<message1->field3.count && !err;i++)
            err = edf_double_encode(edf,message1->field3.values[i]);
    } break
} // edf_Message1_encode

int edf_Message1_free(EDF* edf, Message1* message1)
{
    int key, err = ENOERR;
    case (1) {
        err = edf_int32_free(edf,message1->field1);
    } break
    case (2) {
        if(message1->field2.defined)
            err = edf_fixed64_free(edf,message1->field2.value[0]);
    } break
    case (3) {
        for(i=0;i<message1->field3.count && !err;i++) {
            err = edf_double_free(edf,message1->field3.values[i]);
        }
        edf_free((void*)message1->field3.values);
    } break
} // edf_Message1_free
